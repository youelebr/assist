module ("s2s.load_files", package.seeall)

require ("s2s.api")

--[[ 
	Exctract all important information from a CSV file generated by VPROF
	it extract only the min/max/avg values for each loop and their id 
	to identify them in the binary
 ]]--
function s2s:load_vprof_CSV_file (filename)
   if type (filename) ~= "string" then
      -- Invalid parameter
      return nil
   end
   if fs.exists (filename) == false then
      -- File does not exist
      return nil
   end

   local file = io.open (filename, "r")
   if file == nil then
      -- File can not be openned
      return nil
   end
   
   local results = {}
   local i = 0
   for line in file:lines() do
      if i == 0 then
         -- First line contains only the legend
      else
         local tmp = String:split (line, ",")
         results[i] = {
            loop_id = tonumber (tmp[1]), 
            ite_min = tonumber (tmp[5]),
            ite_max = tonumber (tmp[6]),
            ite_avg = tonumber (tmp[7]),
            --transformation = "VPROFdirective={"..lineStart..","..lineEnd..",LOOP COUNT MAX="..ite_max..", MIN="..ite_min..", AVG="..ite_avg.."}"
         }
      end
      i = i + 1
   end
   file:close ()
   return results
end

--[[ (DEPRECATED) 
	Extract all important information from a CSV file generated by LPROF
	it extract : 
	  -the loop id
	  -the function name
	  -the source_info
	  -the level of the loop
	  -time_p
	  -time_s
	  -cpi_ratio
	to identify them in the binary
 ]]--
function s2s:load_lprof_CSV_file_ (filename)
	print ("load_lprof_CSV_file_")
   if type (filename) ~= "string" then
      -- Invalid parameter
      return nil
   end
   if fs.exists (filename) == false then
   	print("file doesn't exist")
      -- File does not exist
      return nil
   end

   local file = io.open (filename, "r")
   if file == nil then
   	print("file == nil")
      -- File can not be openned
      return nil
   end
   
   local results = {}
   local i = 0
   for line in file:lines() do
      if i == 0 then
         -- First line contains only the legend
      else
         local tmp = String:split (line, ";")
         results[i] = {
            loop_id = tonumber (tmp[1]), 
            function_name = tmp[2],
            source_info = tmp[3],
            level = tmp[4],
            time_p = tonumber (tmp[5]),
            time_s = tonumber (tmp[6]),
            cpi_ratio = tonumber (tmp[7]),
            module = tmp[8]
         }
      end
      i = i + 1
   end
   file:close ()
   return results
end

--[[ (DEPRECATED)
	Extract all important information from a CSV file generated by CQA
	it extract only the vector ratio for each loop if < 75% 
	to maybe apply the block vectorization transformation
 ]]--
function s2s:load_cqa_CSV_file (filename)
   if type (filename) ~= "string" then
      -- Invalid parameter
      return nil
   end
   if fs.exists (filename) == false then
      -- File does not exist
      return nil
   end
   local file = io.open (filename, "r")
   if file == nil then
      -- File can not be openned
      return nil
   end
   
   local results = {}
   local i = 0
   for line in file:lines() do
      if i == 0 then
         -- First line contains only the legend
      else
         local tmp = String:split (line, "\t")

         -- ne prendre les boucles que si le vec ratio est < 75%
         if (tonumber(tmp[78]) < 75) then 
	         results[i] = {
	            loop_id  = tonumber (tmp[5]), 
	            file     = s2s:getFileFromPath((tmp[3])),
	            path     = s2s:getPath(tostring (tmp[3])),
	            lineStart= tonumber (String:split (tmp[4], "-")[1]),
	            lineEnd  = tonumber (String:split (tmp[4], "-")[2]),
	            funcName= tostring (tmp[1]),
	            vecRatio = tonumber (tmp[78]),
	            transfo = "BLOCKVECT"
	         }
         end
      end
      i = i + 1
   end
   file:close ()
   return results
end

function s2s:load_config_file_string (filename, archi)
  local file = io.open (filename, "r")
  local transfo_struct

  transfo_struct = {
   	path=""; 
   	archi="";
   	loop={};
   	func={};
	}


   if not file then
   	print(filename.." doesn't exist.")
      os.exit(1)
   end

   filecontent = file:read("*all")

   transfo_struct.path = filecontent:match 'File[%s]*=[%s]*(%S+)'

   if transfo_struct.path == nil then 
   	transfo_struct.path = getfile_from_basename(fs.basename(filename))
   end

   print(transfo_struct.path)

   if fs.exists (transfo_struct.path) == false then 
   	print ("No file found") 
   	os.exit(1) 
   end

   local transfo_archi = string.match (filecontent, archi.."[%s]*=[%s]*%b{}")
   transfo_struct.archi = transfo_archi

   -- print("Transfo_struct = {")
   -- print("path="..transfo_struct.path)
   -- print("archi="..transfo_struct.archi)
   -- print("loop trans =".."nil")
   -- print("func trans =".."nil")
   -- print("}")
end

--[[ 
	-- loops and func are arrays of transformations. 
	-- Index represent the line of the statement and the value is a set of transformations associated to this statement
--]]
function buildStructuresOfTransformations (loops_trans, funcs_trans) 
	local loopStruct = {}
	local funcStruct = {}
	local i =0;

	-- loops
   for line, trans in pairs(loops_trans) do 
	   --print(" { loop line = "..line.." trans = ".. trans.." }")
	   loopStruct[i] = {}

	   table.insert(loopStruct[i],line)

	   trans = string.gsub(trans,";"," ")
	   for loopdir in string.gmatch(trans, "%S+") do
	   	table.insert(loopStruct[i],loopdir)
	   end

	   i = i + 1 
	end 

	i = 0

	-- Funcs
   for line, trans in pairs(funcs_trans) do 
	   --print(" { loop line = "..line.." trans = ".. trans.." }")
	   funcStruct[i] = {}

	   table.insert(funcStruct[i],line)

	   trans = string.gsub(trans,";"," ")
	   for loopdir in string.gmatch(trans, "%S+") do
	   	table.insert(funcStruct[i],loopdir)
	   end

	   i = i + 1 
	end 
	return loopStruct, funcStruct;
end

--[[ 
	-- Return the number of time which a charactere is in a string. 
--]]
function numberOfElemInString (str, char) 
	local _, cpt = string.gsub(str, char, "")
	return cpt;
end

-- [[
	-- Extract right string from directive
--]]
function buildPrefixTransFromDir(line) 
	-- print("buildPrefixTransFromDir-- line : "..line)
	--stmt= {line, SPECIALIZE(x=3, y<6, k={10,20})}
	local prefix ="";
  local op = "" 
  local varName = ""
  local value = ""


  if     (string.match(line, "%([%s]*%a+[%s]*=[%s]*%d+") ~= nil ) then
  	-- print("DBG = ")
  	substr = string.match(line, "%([%s]*%a+[%s]*=[%s]*%d+")
	 	varName = string.match(substr, "%a+")
	 	value   = string.match(substr, "%d+")
	 	op = "e"
	elseif (string.match(line, "%([%s]*%a+[%s]*<[%s]*%d+")) then
  	-- print("DBG < ")
  	substr  = string.match(line, "%([%s]*%a+[%s]*<[%s]*%d+")
	 	varName = string.match(substr, "%a+")
	 	value   = string.match(substr, "%d+")
	 	op = "i"
	elseif (string.match(line, "%([%s]*%a+[%s]*>[%s]*%d+")) then
  	-- print("DBG > ")
  	substr  = string.match(line, "%([%s]*%a+[%s]*>[%s]*%d+")
	 	varName = string.match(substr, "%a+")
	 	value   = string.match(substr, "%d+")
	 	op = "s"
	elseif (string.match(line, "%([%s]*%a+[%s]*%=[%s]*%{[%s]*%d+[%s]*%,[%s]*%d+[%s]*%}")) then
  	-- print("DBG ={,} ")
  	substr  = string.match(line, "%([%s]*%a+[%s]*%[=]*[%s]*%{[%s]*%d+[%s]*%,[%s]*%d+[%s]*%}")
	 	varName = string.match(substr, "%a+")
	 	value   = string.match(substr, "%d+,")
	 	value   = string.match(substr, ",%d+")
	 	op = "b"
	 	value = value1.."_"..value2
	else
		-- print("ERROR  ! please considere reviewing the line : "..line)
		return ""
	end

	prefix = varName..op..tostring(value)
	nextElem = line:gsub(substr,"")

	while (string.match(nextElem,",")  and substr ~= nil) do

		if     (string.match(nextElem, ",[%s]*%a+[%s]*=[%s]*%d+") ~= nil ) then
	  	-- print("DBG = ")
	  	substr = string.match(nextElem, ",[%s]*%a+[%s]*=[%s]*%d+")
		 	varName = string.match(substr, "%a+")
		 	value   = string.match(substr, "%d+")
		 	op = "e"
		elseif (string.match(nextElem, ",[%s]*%a+[%s]*<[%s]*%d+")) then
	  	-- print("DBG < ")
	  	substr  = string.match(nextElem, ",[%s]*%a+[%s]*<[%s]*%d+")
		 	varName = string.match(substr, "%a+")
		 	value   = string.match(substr, "%d+")
		 	op = "i"
		elseif (string.match(nextElem, ",[%s]*%a+[%s]*>[%s]*%d+")) then
	  	-- print("DBG > ")
	  	substr  = string.match(nextElem, ",[%s]*%a+[%s]*>[%s]*%d+")
		 	varName = string.match(substr, "%a+")
		 	value   = string.match(substr, "%d+")
		 	op = "s"
		elseif (string.match(nextElem, ",[%s]*%a+[%s]*%=[%s]*%{[%s]*%d+[%s]*%,[%s]*%d+[%s]*%}")) then
	  	-- print("DBG ={,} ")
	  	substr  = string.match(nextElem, ",[%s]*%%a+[%s]*%[=]*[%s]*%%{[%s]*%%d+[%s]*%,[%s]*%%d+[%s]*%%}")
		 	varName = string.match(substr, "%a+")
		 	value   = string.match(substr, "%d+,")
		 	value   = string.match(substr, ",%d+")
		 	op = "b"
		 	value = value1.."_"..value2
		else
			break
		end

		nextElem = nextElem:gsub(substr,"")

		prefix = prefix.."_"..varName..op..tostring(value)
	end

	-- print("prefix = "..prefix)
	return prefix;
end

function specializeTrans(trans)

	if (string.match(trans,"SPECIALIZE") ~= nil) then 

		local transfos = String:split (trans, ";")
		local prefix = buildPrefixTransFromDir(transfos[1])

		trans = string.gsub(trans, ";", "; ")

		for _, directive in pairs(transfos) do
				if ( string.match(directive, "SPECIALIZE") == nil )then 
					newdir = "IF_SPE_"..prefix.."_"..directive
					trans = string.gsub(trans,directive, string.gsub(newdir, " ", ""))
				end
		end

	end

	return trans		
end

--[[ 
	Fill the loops_trans structure with the line information (or label)
--]]
function browseLoops(loops_trans, loops, prefix)
	for _, struct in pairs(loops) do

		local loopLine = struct["line"]
		local loopLabel = struct["label"]
		
		for _, trans in pairs(struct["transformation"]) do 
			speTrans = specializeTrans(trans)
			if loopLine ~= nil then 
				if (loops_trans[loopLine] ~= nil) then 
					loops_trans[loopLine] = loops_trans[loopLine]..";"..prefix..speTrans
				else
					loops_trans[loopLine] = prefix..speTrans
				end
			else --loopLabel
				if (loops_trans[loopLabel] ~= nil) then 
					loops_trans[loopLabel] = loops_trans[loopLabel]..";"..prefix..speTrans
				else
					loops_trans[loopLabel] = prefix..speTrans
				end
			end
		end
	end
end

function browseFuncs(funcs_trans, functions, loops_trans)
	for _, struct in pairs(functions) do

		local funcLine = struct["line"]
		local prefixTrans = ""
		local cpt=0

		for _, trans in pairs(struct["transformation"]) do 
			if (funcs_trans[funcLine] ~= nil) then 
			 funcs_trans[funcLine] = funcs_trans[funcLine]..";"..trans
			else
			 funcs_trans[funcLine] = trans
			end
			prefixTrans = buildPrefixTransFromDir(trans)
			cpt = cpt +1
		end

		if ( cpt ==1 )then 
			if (prefixTrans ~= "") then 
				prefixTrans = "IF_SPE_"..prefixTrans.."_"
			end
			if (struct["loops"] ~= nil ) then 
				browseLoops(loops_trans, struct["loops"], prefixTrans)
			end
		else
			print ("ERROR, you must enter only one transformation at time on function if you want to transform loop follogin a specific specialization... (à reformuler ...)")
			os.exit(1)
		end


	end
end

function s2s:load_config_file_v2 (filename, archi)
	local session={}
	local loops_trans = {}
	local funcs_trans = {}

	-- Load the descriptor file, which have been wrote as a lua file
	dofile(filename)
	s2s:DBG("Load arch : "..archi, 2)
	session = Arch[archi]

	if (session["functions"] ~= nil ) then 
		s2s:DBG("Browse functions ", 2)
		browseFuncs(funcs_trans, session["functions"], loops_trans)
	end

	if (session["loops"] ~= nil) then 
		s2s:DBG("Browse loops ", 2)
		browseLoops(loops_trans, session["loops"], "")
	end

	if (archi ~= "All") then
		s2s:DBG("Load arch : All ", 2)
		session = Arch["All"]

		if (session["functions"] ~= nil ) then 
			s2s:DBG("Browse functions ", 2)
			browseFuncs(funcs_trans, session["functions"], loops_trans)
		end

		if (session["loops"] ~= nil) then 
			s2s:DBG("Browse loops ", 2)
			browseLoops(loops_trans, session["loops"], "")
		end
	end
	return File, buildStructuresOfTransformations(loops_trans,funcs_trans)
end

-- Create a configuration file template.
-- Withall fields detailed
function s2s:generate_config_file (filename)
  local file = io.open (filename, "w")
  if file == nil then
    Message:error ("Can not create output file "..filename)
    return false
  end

  file:write ("-- ================================================================================================ --\n")
  file:write ("--                                   Example of a Descriptor file                                   --\n")
  file:write ("-- ================================================================================================ --\n")

	file:write ("-- This is an example of descriptor file.\n")
	file:write ("-- \n")
	file:write ("-- A descriptor file is compose as follow :\n")
	file:write ("-- * File = \"<path to the file between quotes>\" : This field indicate where to find the file to transform.\n")
	file:write ("-- * Arch = {<All informations>} : All you have to write have to be between the braces of the field \"Arch\".\n")
	file:write ("-- 	* <target_architecture|All> = { } : You can call ASSIST with the option \"-arch=<targetArch>\" to only apply transformation indicate by the name given. By default we will search \"All\"\n")
	file:write ("-- 		* functions = { : This field reference all transformations associated to functions \n")
	file:write ("-- 			{\n")
	file:write ("-- 				* line = <line> : Indicate the line of the function\n")
	file:write ("-- 				* transformation = { \"<transformation>\"} : Write the transformation you want to apply. Refer to the list of directives in the documentation. \n")
	file:write ("-- 				* loops = { } : Uf you want to specialize a function and apply transformation on loops inside th specialized version indicate transforamtions here.\n");
	file:write ("-- 			}[, {... }] : Put a coma and add a new section, if you want to transform another function. \n")
	file:write ("-- 			              If you want to specialize multiple time a function and apply specific transformations inside, you have to separate each versions \n")
	file:write ("-- 		\n")
	file:write ("-- 		* loops = { : We are write here all that references to transformations associated to loops \n")
	file:write ("-- 			{\n")
	file:write ("-- 				* line = <line> : Indicate the line of the loop \n")
	file:write ("-- 				* transformation = {\"<trans1>\" [, \"<trans2>\"] ... } : To fill with a set of trnasformations to apply on the loop line <line>.\n")
	file:write ("-- 			}, : If there are several loops to be filled in, put a comma and add a new section.\n")
	file:write ("-- 			{\n")
	file:write ("-- 				* line = <line> : Always the line of the loop \n")
	file:write ("-- 				* transformation = {\"<trans1>; <trans2>\" [, \"<trans3>\"] ... } : If you want to apply a transformation on a previous transformation, put them in the same section between quotes and separate them with a \";\". \n")
	file:write ("-- 			}\n")
	file:write ("-- \n")
	file:write ("-- 	* <target_arch2> = { ... } : It's possible to define multiple architectures, but we will apply transformation on only one at time.\n")
	file:write ("-- \n")
	file:write ("-- \n")
	file:write ("-- An example of file descritor is given below : \n")
	file:write ("\n")
	file:write ("\n")
	file:write("File = \"<path/to/the/file/to/transform>\" -- Quotes around the path must be present.\n")
	file:write("\n")
	file:write("Arch = { \n")
	file:write("  All = { -- The default target architecture searched is \"All\", but the architecture target can be specify in the command line with the option \"-arch=\"  \n")
	file:write("    functions = { \n")
	file:write("      { -- All items have to be in a section between \"{\" \"}\" ")
	file:write("        line = 18, -- The function is define line 18")
	file:write("        transformation = {\"SPECIALIZE(var1=15, var2={10,20})\"}, -- In this example, the function line 18, will be specialize with: var1=15 and var2 is between 10 and 20.\n")
	file:write("        loops = { -- For loops inside the specialized function\n")
	file:write(" 	 	    	{ line = 27, transformation = {\"FULLUNROLL\"} } -- The loops line 27, in the non specialized function, will be full unrolled.\n")
	file:write("		  	}\n")
	file:write(" 	    }, \n")
	file:write(" 	    { -- Other section for another function (or the same but with another transformation).\n")
	file:write("        line = 18, -- In this case we keep the function line 18.\n")
	file:write("        transformation = {\"SPECIALIZE(var1=15, var2=5)\"}, -- And we will specialize it with : var1 = 15 and var2 = 5 \n")
	file:write("        loops = { -- For loops inside this version of the function.\n")
	file:write("		 	 		{ line = 27, transformation = {\"TILE=5\"} } -- The loops line 27 will be tiled by 5 in this version of the function.\n")
	file:write("				} -- End of the list of loops\n")
	file:write(" 	    } -- End if the list of functions (no comma here)\n")
	file:write(" 	 	}, -- next item \n")
	file:write("\n")
	file:write("		loops = { -- Listing of transformation on loops (in functions non specialized\n")
	file:write("		  { line = 31, transformation = {\"SPECIALIZE(size=10); TILE=2\"}}, -- The loops line 31 will be specialized with size = 10 and in the specialized version tiled by 2.\n")
	file:write("		                                                                     -- The tilling will be done only on the version specialized  .\n")
	file:write("		  -- With this declarations we will have two version of the loop line 31; one with size=10 and tile by 2, and the original loop.\n")
	file:write("		  { label = \"LOOP1\", transformation = {\"SPECIALIZE(size=20); TILE=5\", \"SPECIALIZE(size=30); TILE=10\"}}  -- It also possible to indicate multiple transformations to perform.\n")
	file:write("		                                                                                                      -- In this example the loop will be specialized with the variable \"size\"=20 then tile by 5.\n")
	file:write("		                                                                                                      -- This loop will also specialized with size = 30 then tile by 10.\n")
	file:write("          -- Instead of line, you can use a label to identify a loop. This label must correspond to a directive above a loop in fhte file (e.g. MAQAO LOOP1\n")
	file:write("		}\n")
	file:write("	},\n")
	file:write("\n")
	file:write("	x86 = { -- To define another architecture to perform other(/same) transformations.\n")
	file:write("		-- ... \n")
	file:write("	}\n")
	file:write("}\n")
end

-- Create a configuration file template.
-- Without all details about fields
function s2s:generate_empty_config_file (filename)
  local file = io.open (filename, "w")
  if file == nil then
    Message:error ("Can not create output file "..filename)
    return false
  end

  file:write ("-- ================================================================================================ --\n")
  file:write ("--                                   Empty Descriptor file                                   --\n")
  file:write ("-- ================================================================================================ --\n")
	file:write ("\n")
	file:write("File = \"\" -- Quotes around the path must be present.\n")
	file:write("\n")
	file:write("Arch = { \n")
	file:write("	All = { \n")
	file:write("		functions = {\n")
	file:write("    	{\n")
	file:write("      	line = 0,\n")
	file:write("      	transformation = {\"\"},\n")
	file:write("      	loops = {\n")
	file:write(" 	 	    	{ line = 0, transformation = {\"\"} }\n")
	file:write("		  	}\n")
	file:write(" 	   	},\n")
	file:write(" 	   	{ line = 0, transformation = {\"\"}, loops = { { line = 0, transformation = {\"\"} } } }\n")
	file:write("		}\n")
	file:write("\n")
	file:write("		loops = {\n")
	file:write("		  { line = 0, transformation = {\"\"}},\n")
	file:write("		  { label = \"looplabel\", transformation = {\";\", \";\"}}\n")
	file:write("		}\n")
	file:write("	},\n")
	file:write("\n")
	file:write("	target1 = { \n")
	file:write("\n")
	file:write("	}\n")
	file:write("}\n")
end

-- Load the file generate by oneview
function s2s:load_oneview_file (filename)
	dofile(filename)
	return oneview_cleaning_report
end

-- Generate the file for the half auto option
function s2s:generate_auto_config_file(filename)
	local file = io.open(filename, "w")
	if file == nil then
		Message:error ("Can not create output file "..filename)
		return false
	end

	file:write ("-- ================================================================================================ --\n")
    file:write ("--                                            Config File                                           --\n")
    file:write ("-- ================================================================================================ --\n")
    file:write ("\n")
    file:write("-- The path to the Makefile. Quotes around the path must be present.\n")
    file:write("\tMakefile = \"\"\n\n")
    file:write("-- Write here if there is options for compilation.\n")
    file:write("\tMakefile_options = \"\"\n\n")
    --[[
    file:write("-- Path to the binary generated by the Makefile.\n")
    file:write("\tBinary = \"\"\n\n")
    file:write("-- Specify how the application must be run.\n")
	file:write("\tRun_command = \"\"\n\n")
	]]
	file:write("-- path to the directory root of source files.\n")
	file:write("\tsrc = \"\" \n\n\n")	
	file:write("-- Time average minimum of a loop in percent. Set to 1.5% by default.\n")
    file:write("\tloop_time_min = 1.5\n\n")
	file:write("-- ============ ONEVIEW SPECIFICATIONS ============ --\n\n")
	file:write("-- Path to the maqao binary to launch Oneview.\n")
	file:write("\tBin_oneview_path = \"\"\n\n")
	file:write("-- The type of report to create.\n")
	file:write("-- Oneview handles for now type \"one\", \"two\" or \"three\". The report two is the default one.\n")
	file:write("-- Beware that some reports won't give some results. For instance, the report one which don't give DECAN and VPROF results. For instance, the report one.\n")
	file:write("-- See maqao oneview --help for more informations")
	file:write("\treport = \"two\"\n\n")
	file:write("-- The path to Oneview config file containing experiment parameters. It is the config file generated by Oneview, named, by default, config.lua.\n")
	file:write("-- To generate it, execute : maqao oneview --create-config\n")
	file:write("\tOneview_config_file = \"\"")
	--[[
	file:write("-- Path to the dataset directory used by the application\n")
	file:write("-- Use an empty string or remove the declaration if no\n")
	file:write("-- dataset is required by the application\n")
	file:write("\tdataset = \"\"\n")
	]]
	file:close()
end

-----------------------------------------------------
-- Functions that load the auto configuration file --
-----------------------------------------------------
local function _load_config_binary(value, auto_input)
   if type (value) ~= "string" 
   or value == "" then
      ret = false
      Message:error ("In configuration file: binary must not be an empty string")
   else
      auto_input.binary = value
      return true
   end
   return false
end

local  function _load_config_makefile(value, auto_input)
	if type (value) ~= "string" 
   or value == "" then
      ret = false
      Message:error ("In configuration file: makefile must not be an empty string")
   else
      auto_input.makefile = value
      if fs.exists(auto_input.makefile) == false then
      	ret = false
      	Message:error("In configuration file: the path to Makefile does not exist")
      end
      auto_input.makefile = string.gsub(auto_input.makefile, "/Makefile$", "")
      return true
   end
   return false
end

local  function _load_config_make_opt(value, auto_input)
	if value == nil then
    auto_input.make_opt = ""
  elseif type (value) ~= "string" then
    ret = false
    Message:error ("In configuration file: Makefile_options must be nil or a string")
  else
    auto_input.make_opt = value
    return true
  end
  return false
end

local function _load_config_run_cmd(value, auto_input)
	if value == nil then
    auto_input.run_cmd = ""
  elseif type (value) ~= "string" then
    ret = false
    Message:error ("In configuration file: Run_command must be nil or a string")
  else
    auto_input.run_cmd = value
    return true
  end
  return false
end

local function _load_config_src(value, auto_input)
	if type (value) ~= "string" 
   or value == "" then
      ret = false
      Message:error ("In configuration file: src must not be an empty string")
   else
      auto_input.src = string.gsub(value, "/$", "")
      if fs.exists(auto_input.src) == false then
      	ret = false
      	Message:error("In configuration file: the path to src does not exist")
      end
      return true
   end
   return false
end

local function _load_config_bin_ov(value, auto_input)
	if type (value) ~= "string" 
   or value == "" then
      ret = false
      Message:error ("In configuration file: bin_ov_path must not be an empty string")
   else
      auto_input.ov_bin = value
      if fs.exists(auto_input.ov_bin) == false then
      	ret = false
      	Message:error("In configuration file: the path to Oneview binary does not exist")
      end
      return true
   end
   return false
end

local function _load_config_report(value, auto_input)
	if type (value) ~= "string" 
   or value == "" then
      ret = false
      Message:error ("In configuration file: report must not be an empty string")
   else
      auto_input.report = value
      return true
   end
   return false
end

local function _load_config_dataset(value, auto_input)
   if value == nil then
      auto_input.dataset = ""
   elseif type (value) ~= "string" then
      ret = false
      Message:error ("In configuration file: dataset must be nil or a string")
   else
      auto_input.dataset = value
      return true
   end

   return false
end

local function _load_ov_config_file(value, auto_input)
   if value == nil then
      auto_input.ov_config = ""
   elseif type (value) ~= "string" then
      ret = false
      Message:error ("In configuration file: path to oneview config file must be a string")
   else
      auto_input.ov_config = value
      if fs.exists(auto_input.ov_config) == false then
      	ret = false
      	Message:error("In configuration file: the path to Oneview config file does not exist")
      end
      return true
   end

   return false
end

local function _load_config_loop_time_min(value, auto_input)
   if value == nil then
      auto_input.loop_time_min = 1.5
   elseif type (value) ~= "number" then
      ret = false
      Message:error ("In configuration file: loop_time_min must be nil or a number")
   else
      auto_input.loop_time_min = value
      return true
   end

   return false
end

function s2s:load_auto_config_file(config_file, auto_input)
	if fs.exists(config_file) == false then
		Message:error("Config file does not exist")
		return false
	end
  dofile(config_file)
  _load_config_makefile(Makefile, auto_input)
  _load_config_make_opt(Makefile_options, auto_input)
  _load_config_loop_time_min(loop_time_min, auto_input)
	-- _load_config_binary(Binary, auto_input)
	-- _load_config_run_cmd(Run_command, auto_input)
  _load_config_src(src, auto_input)
  _load_config_bin_ov(Bin_oneview_path, auto_input)
  _load_ov_config_file(Oneview_config_file, auto_input)
  _load_config_report(report, auto_input)
	-- _load_config_dataset(dataset, auto_input)
  return ret
end
